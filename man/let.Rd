% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{let}
\alias{let}
\alias{letrec}
\alias{let..}
\alias{letrec..}
\title{let, letrec, let*, letrec*}
\usage{
let(expr, ..., parent = parent.frame())

letrec(expr, ..., parent = parent.frame())

let..(expr, ..., parent = parent.frame())

letrec..(expr, ..., parent = parent.frame())
}
\arguments{
\item{expr}{Expression to be evaluated in custom environment}

\item{...}{named variables or functions which will be bounded in the
evaluation environment.}

\item{parent}{Optionally a parent environment.}
}
\value{
Value of the evaluated expression.
}
\description{
Utilities inspired in lisp/scheme let and letrec
Allow evaluating an expression in an environment with custom bounded
variables. Similar to \code{with} and \code{local} but variables are
passed individually in ... instead of lists or code blocks. Specially useful
with functions.
}
\details{
\code{let} will evaluate the expressions given in ... in the current
environment or the environment given in parent, while \code{letrec} will
evaluate the dots in an environment in which the variables are bound. This
means that functions passed in ... to \code{let} cannot see themselves, which
is useful to allow them to call functions in the parent (the current)
environment with the same name from inside the functions, potentially adding
additional functionality.
On the other hand, \code{letrec} can see and recursively call all values
passed in ..., this is the same as \code{local()}, but with each function
passed individually as an argument instead of a code block.
\code{let..} and \code{letrec..} are variants much alike scheme's let\* and
letrec*, in which each argument can see the previous only. They are
implemented as recursive nested calls, i.e. \code{let..(<expr>, a, b, ...)}
is the same as \code{... let(let(expr, a), b), ... }
}
\examples{
# let allow you to refer to an outside function with the same name without
# recursion:
f <- function(x) x ^ 2 - 5
f(2)  # -1
let(f(2), f = function(x) abs(f(x)))  # 1

# but this is an error as "let" functions cannot see themselves
try(let(
  k(10),
  k = function(y) f(y),
  f = function(x) if(x) x*k(x-1) else 1))

# letrec functions are recursive:
letrec(
  k(10),
  k = function(y) f(y),
  f = function(x) if(x) x*k(x-1) else 1)

# let.. can see previously defined arguments in order:
let..(g(2),
  f = function(x) x ^ 2 - 5,
  g = function(x) abs(f(x)))  # 1

}
